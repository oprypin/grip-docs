{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Grip is a microframework for building RESTful web applications. It is designed to be modular and easy to use, with the ability to scale up to the limits of the Crystal programming language. It offers extensibility and it has integrated middleware called \"pipes\" which alter the parts of the request/response context and pass it on to the actual endpoint. It has a router which somewhat resembles that of Phoenix framework 's router and most of all it is fast, peaking at 1,663,946 requests/second for plain text response. Project structure \u00b6 For example a project structure of a normal Grip application should look like this: # In this example the project name is `Echo` lib/ # Library src/ application.cr # Entry file echo/ # Business logic, database interaction, etc. ... echo_web/ # Web layer to interact with the business layer. views/ # Views directory ... pipes/ # Pipes directory ... controllers/ # Controllers directory http/ # HTTP directory websocket/ # WebSocket directory exception/ # Exception directory shards.yml # The packages congfiuration file For a better representation of the structure and a starting point use a cookiecutter template defined here .","title":"Prelude"},{"location":"#project-structure","text":"For example a project structure of a normal Grip application should look like this: # In this example the project name is `Echo` lib/ # Library src/ application.cr # Entry file echo/ # Business logic, database interaction, etc. ... echo_web/ # Web layer to interact with the business layer. views/ # Views directory ... pipes/ # Pipes directory ... controllers/ # Controllers directory http/ # HTTP directory websocket/ # WebSocket directory exception/ # Exception directory shards.yml # The packages congfiuration file For a better representation of the structure and a starting point use a cookiecutter template defined here .","title":"Project structure"},{"location":"advanced_routing/","text":"The more advanced the route is the more time it takes when executed, since the call to the index function is an indirect call, meaning that the index/1 never existed in the Grip::Controllers::Http class it needs to be wrapped in a Proc which then needs to be called. class DemoController < Grip :: Controllers :: Http def index ( context : Context ) : Context context . json ( nil ) end end class Application < Grip :: Application def routes pipeline :api , [ Pipes :: PoweredByHeader . new ] pipeline :web , [ Pipes :: SecureHeaders . new ] # The routing occurs via the `get` macro which instantiates the controller class and assigns a route # to the routing mechanism. # # `GET /` -> CLIENT -> SERVER -> ROUTER -> ROUTE -> PIPELINE -> CONTROLLER -> index/1 # # You can route the request through unlimited amounts of pipelines. scope \"/\" do pipe_through [ :web , :api ] get \"/\" , DemoController , as : :index end scope \"/api/v1\" do pipe_through :api get \"/\" , DemoController , as : :index end end end","title":"Advanced routing"},{"location":"application/","text":"Application class is a building class which initializes the crucial parts of the web-framework, it contains the main handler stack and the HTTP server. Available methods \u00b6 host/0 port/0 reuse_port/0 router/0 server/0 key_file/0 cert_file/0 run/0 host \u00b6 The host of the server. class Application < Grip :: Application def host \"127.0.0.1\" end end port \u00b6 The port of the server. class Application < Grip :: Application def port 6969 end end reuse_port \u00b6 The reuse_port boolean of the server. class Application < Grip :: Application def reuse_port true end end router \u00b6 The router of the application. class Application < Grip :: Application def router [] of HTTP :: Handler end end server \u00b6 The server of the application. class Application < Grip :: Application def server HTTP :: Server . new ( router ) end end key_file \u00b6 The key_file of the application. class Application < Grip :: Application def key_file \"SSL_KEY_FILE_LOCATION\" end end cert_file \u00b6 The cert_file of the application. class Application < Grip :: Application def cert_file \"SSL_CERTIFICATE_FILE_LOCATION\" end end run \u00b6 The run of the application executes the main application loop.","title":"Application"},{"location":"application/#available-methods","text":"host/0 port/0 reuse_port/0 router/0 server/0 key_file/0 cert_file/0 run/0","title":"Available methods"},{"location":"application/#host","text":"The host of the server. class Application < Grip :: Application def host \"127.0.0.1\" end end","title":"host"},{"location":"application/#port","text":"The port of the server. class Application < Grip :: Application def port 6969 end end","title":"port"},{"location":"application/#reuse_port","text":"The reuse_port boolean of the server. class Application < Grip :: Application def reuse_port true end end","title":"reuse_port"},{"location":"application/#router","text":"The router of the application. class Application < Grip :: Application def router [] of HTTP :: Handler end end","title":"router"},{"location":"application/#server","text":"The server of the application. class Application < Grip :: Application def server HTTP :: Server . new ( router ) end end","title":"server"},{"location":"application/#key_file","text":"The key_file of the application. class Application < Grip :: Application def key_file \"SSL_KEY_FILE_LOCATION\" end end","title":"key_file"},{"location":"application/#cert_file","text":"The cert_file of the application. class Application < Grip :: Application def cert_file \"SSL_CERTIFICATE_FILE_LOCATION\" end end","title":"cert_file"},{"location":"application/#run","text":"The run of the application executes the main application loop.","title":"run"},{"location":"basic_routing/","text":"Routing is the key feature which distinguishes Grip from other Crystal based web frameworks. class DemoController < Grip :: Controllers :: Http def get ( context : Context ) : Context context . json ( nil ) end end class Application < Grip :: Application def routes # The routing occurs via the `get` macro which instantiates the controller class and assigns a route # to the routing mechanism. # # `GET /` -> CLIENT -> SERVER -> ROUTER -> ROUTE -> CONTROLLER -> get/1 # get \"/\" , DemoController end end","title":"Basic routing"},{"location":"context/","text":"Context is a class which contains the Request, Response structures of an HTTP server, since Crystal Language allows us to extend its core features we have decided to add couple of helper functions to the context class. Available methods \u00b6 delete_req_header/1 delete_resp_header/1 get_req_header/1 get_resp_header/1 halt/0 merge_resp_headers/1 put_req_header/2 put_resp_header/2 put_status/1 send_resp /1 json/2 html/2 text/2 binary/2 fetch_json_params/0 fetch_query_params/0 fetch_body_params/0 fetch_file_params/0 fetch_path_params/0 delete_req_header \u00b6 Deletes a request header if present. def get ( context : Context ) : Context context . delete_req_header ( \"Referer\" ) . text ( nil ) end delete_resp_header \u00b6 Deletes a response header if present. def get ( context : Context ) : Context context . json ( \"Hello, World!\" ) . delete_resp_header ( \"Content-Type\" ) end get_req_header \u00b6 Returns the values of the request header specified by key . def get ( context : Context ) : Context referer = context . get_req_header ( \"Referer\" ) context . json ( { \"referer\" => referer } ) end get_resp_header \u00b6 Returns the values of the response header specified by key . def get ( context : Context ) : Context content_type = context . get_resp_header ( \"Content-Type\" ) context . json ( { \"contentType\" => content_type } ) end halt \u00b6 Halts the function chain by closing the response stream. def get ( context : Context ) : Context context . json ( \"Hello, World!\" ) . halt end merge_resp_headers \u00b6 Merges a series of response headers into the context. def get ( context : Context ) : Context context . merge_resp_headers ({ \"Content-Type\" => \"application/json\" }) . send_resp ( \"Hello, World!\" ) end put_req_header \u00b6 Adds a new request header (key) if not present, otherwise replaces the previous value of that header with value . def get ( context : Context ) : Context context . put_req_header ( \"Referer\" , \"www.google.com\" ) . json ( \"Hello, World\" ) end put_resp_header \u00b6 Adds a new response header (key) if not present, otherwise replaces the previous value of that header with value . def get ( context : Context ) : Context context . put_resp_header ( \"Content-Type\" , \"application/json\" ) . send_resp ( \"Hello, World!\" ) end put_status \u00b6 Assigns the given status code to the context response. def get ( context : Context ) : Context context . put_status ( 400 ) . json ( \"Bad request\" ) end send_resp \u00b6 Sends a response to the client. def get ( context : Context ) : Context context . send_resp ( \"Hello, World!\" ) end json \u00b6 Sends JSON response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . json ( \"Hello, World!\" , \"application/json; charset=UTF-8\" ) end html \u00b6 Sends HTML response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . html ( \"Hello, World!\" ) end text \u00b6 Sends text response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . text ( \"Hello, World!\" ) end binary \u00b6 Sends binary response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . binary ( \"Hello, World!\" ) end fetch_json_params \u00b6 Fetches JSON parameters from the JSON parser. def get ( context : Context ) : Context params = context . fetch_json_params context . json ( params ) end fetch_query_params \u00b6 Fetches query parameters from the query string. def get ( context : Context ) : Context params = context . fetch_query_params context . json ( params ) end fetch_body_params \u00b6 Fetches body parameters from the body parser. def get ( context : Context ) : Context params = context . fetch_body_params context . json ( params ) end fetch_file_params \u00b6 Fetches file parameters from the file parser. def get ( context : Context ) : Context params = context . fetch_file_params context . json ( params ) end fetch_path_params \u00b6 Fetches path parameters from the path parser. def get ( context : Context ) : Context params = context . fetch_path_params context . json ( params ) end","title":"Context"},{"location":"context/#available-methods","text":"delete_req_header/1 delete_resp_header/1 get_req_header/1 get_resp_header/1 halt/0 merge_resp_headers/1 put_req_header/2 put_resp_header/2 put_status/1 send_resp /1 json/2 html/2 text/2 binary/2 fetch_json_params/0 fetch_query_params/0 fetch_body_params/0 fetch_file_params/0 fetch_path_params/0","title":"Available methods"},{"location":"context/#delete_req_header","text":"Deletes a request header if present. def get ( context : Context ) : Context context . delete_req_header ( \"Referer\" ) . text ( nil ) end","title":"delete_req_header"},{"location":"context/#delete_resp_header","text":"Deletes a response header if present. def get ( context : Context ) : Context context . json ( \"Hello, World!\" ) . delete_resp_header ( \"Content-Type\" ) end","title":"delete_resp_header"},{"location":"context/#get_req_header","text":"Returns the values of the request header specified by key . def get ( context : Context ) : Context referer = context . get_req_header ( \"Referer\" ) context . json ( { \"referer\" => referer } ) end","title":"get_req_header"},{"location":"context/#get_resp_header","text":"Returns the values of the response header specified by key . def get ( context : Context ) : Context content_type = context . get_resp_header ( \"Content-Type\" ) context . json ( { \"contentType\" => content_type } ) end","title":"get_resp_header"},{"location":"context/#halt","text":"Halts the function chain by closing the response stream. def get ( context : Context ) : Context context . json ( \"Hello, World!\" ) . halt end","title":"halt"},{"location":"context/#merge_resp_headers","text":"Merges a series of response headers into the context. def get ( context : Context ) : Context context . merge_resp_headers ({ \"Content-Type\" => \"application/json\" }) . send_resp ( \"Hello, World!\" ) end","title":"merge_resp_headers"},{"location":"context/#put_req_header","text":"Adds a new request header (key) if not present, otherwise replaces the previous value of that header with value . def get ( context : Context ) : Context context . put_req_header ( \"Referer\" , \"www.google.com\" ) . json ( \"Hello, World\" ) end","title":"put_req_header"},{"location":"context/#put_resp_header","text":"Adds a new response header (key) if not present, otherwise replaces the previous value of that header with value . def get ( context : Context ) : Context context . put_resp_header ( \"Content-Type\" , \"application/json\" ) . send_resp ( \"Hello, World!\" ) end","title":"put_resp_header"},{"location":"context/#put_status","text":"Assigns the given status code to the context response. def get ( context : Context ) : Context context . put_status ( 400 ) . json ( \"Bad request\" ) end","title":"put_status"},{"location":"context/#send_resp","text":"Sends a response to the client. def get ( context : Context ) : Context context . send_resp ( \"Hello, World!\" ) end","title":"send_resp"},{"location":"context/#json","text":"Sends JSON response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . json ( \"Hello, World!\" , \"application/json; charset=UTF-8\" ) end","title":"json"},{"location":"context/#html","text":"Sends HTML response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . html ( \"Hello, World!\" ) end","title":"html"},{"location":"context/#text","text":"Sends text response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . text ( \"Hello, World!\" ) end","title":"text"},{"location":"context/#binary","text":"Sends binary response. The function has an optional second argument for the Content-Type header. def get ( context : Context ) : Context context . binary ( \"Hello, World!\" ) end","title":"binary"},{"location":"context/#fetch_json_params","text":"Fetches JSON parameters from the JSON parser. def get ( context : Context ) : Context params = context . fetch_json_params context . json ( params ) end","title":"fetch_json_params"},{"location":"context/#fetch_query_params","text":"Fetches query parameters from the query string. def get ( context : Context ) : Context params = context . fetch_query_params context . json ( params ) end","title":"fetch_query_params"},{"location":"context/#fetch_body_params","text":"Fetches body parameters from the body parser. def get ( context : Context ) : Context params = context . fetch_body_params context . json ( params ) end","title":"fetch_body_params"},{"location":"context/#fetch_file_params","text":"Fetches file parameters from the file parser. def get ( context : Context ) : Context params = context . fetch_file_params context . json ( params ) end","title":"fetch_file_params"},{"location":"context/#fetch_path_params","text":"Fetches path parameters from the path parser. def get ( context : Context ) : Context params = context . fetch_path_params context . json ( params ) end","title":"fetch_path_params"},{"location":"deployment/","text":"Heroku \u00b6 You can use heroku-buildpack-crystal to deploy your Grip application to Heroku. Cross Compilation \u00b6 Cross-compilation is supported and it can be achieved using this guide","title":"Deployment"},{"location":"deployment/#heroku","text":"You can use heroku-buildpack-crystal to deploy your Grip application to Heroku.","title":"Heroku"},{"location":"deployment/#cross-compilation","text":"Cross-compilation is supported and it can be achieved using this guide","title":"Cross Compilation"},{"location":"error_handling/","text":"Grip comes with a pre-defined error handlers for the JSON response type. You can customize the built-in error pages or even add your own using the error macro. class IndexController < Grip :: Controllers :: Http def get ( context : Context ) : Context # Pre-defined classes for specific error codes, https://github.com/grip-framework/exceptions. raise Exceptions :: NotFound . new end end class NotFoundController < Grip :: Controllers :: Exception # To keep the structure of the project # we still inherit from the Base class which forces us # to define the default `call` function. def call ( context : Context ) : Context context . json ( { \"errors\" => [ context . exception . not_nil! . to_s ] } ) end end class ForbiddenController < Grip :: Controllers :: Exception def call ( context : Context ) : Context context . put_status ( 403 ) # Raised error automatically carries over the status code of the exception. . json ( { \"error\" => [ \"You lack privileges to access the current resource!\" ] } ) end end class Application < Grip :: Application def routes error 403 , ForbiddenController error 404 , NotFoundController get \"/\" , IndexController end end Keep in mind that if you won't use the Exceptions class this will just return as a normal response: class IndexController < Grip :: Controllers :: Http def get ( context : Context ) : Context context . put_status ( 404 ) . html ( \"<p>404 Not found</p>\" ) . halt end end and this will trigger an error handler defined in the routes method of the application: class IndexController < Grip :: Controllers :: Http def get ( context : Context ) : Context raise Exceptions :: NotFound . new end end you can also raise any exception you want and handle it in the error handler like this: class ArgumentException < Exceptions :: Base @status = HTTP :: Status :: BAD_REQUEST def initialize ( @message : String = \"Argument error\" ) end end class IndexController < Grip :: Controllers :: Http def get ( context : Context ) : Context raise ArgumentException . new ( \"Something went wrong\" ) end end class BadRequestController < Grip :: Controllers :: Exception def call ( context : Context ) : Context case context . exception . not_nil! when :: Exceptions :: BadRequest context . json ( { id : UUID . random . to_s , message : \"400 Bad request\" , } ) when ArgumentException context . json ( { id : UUID . random . to_s , message : \"An argument error has occured, #{ context . exception . not_nil! } \" , } ) else context . halt end end end","title":"Error handling"},{"location":"filtering/","text":"Important note: This should not be used by plugins/addons, instead they should do all their work in their own middleware. Deprecated: 4.x.x doesn't support filtering anymore. Before and after filters are evaluated before and after each request within the same context as the routes. They can modify the request and response. The current filter supports all of the verbs which are RESTful, for example defining a before get filter looks like this: class DemoFilter < Grip :: Controllers :: Filter def call ( context : Context ) : Context context . json ( \"Hello, World!\" ) end end class Application < Grip :: Application def routes filter :before , :get , \"/\" , DemoFilter end end defining an after post filter looks like this: class DemoFilter < Grip :: Controllers :: Filter def call ( context : Context ) : Context context . json ( \"Hello, World!\" ) end end class Application < Grip :: Application def routes filter :after , :post , \"/\" , DemoFilter end end","title":"Filtering"},{"location":"getting_started/","text":"1.Init a Crystal project. crystal init app demo && cd demo 2.Add the dependency to your shard.yml and run shards install . dependencies : grip : github : grip-framework/grip 3.Write down the following code in src/demo.cr . require \"grip\" class DemoController < Grip :: Controllers :: Http def get ( context : Context ) context . put_status ( 201 ) # Put a response status code. . put_resp_header ( \"Server\" , \"TornadoServer/6.0.4\" ) # Put a response header. . json ( # Respond with JSON encoded data. { \"id\" => 1 } ) end end class Application < Grip :: Application def routes get \"/\" , DemoController end end app = Application . new app . run 4.Run server. crystal src/demo.cr 5.Send request. curl \"http://0.0.0.0:5000/\" 6.Auto restart server. # Use nodemon to watch file changed and auto restart server. sudo npm install -g nodemon nodemon -e \"cr,yml\" --exec \"crystal run\" src/demo.cr","title":"Getting Started"},{"location":"installation/","text":"Add this to your application's shard.yml : dependencies : grip : github : grip-framework/grip And run this command in your terminal: shards install","title":"Installation"},{"location":"intermediate_routing/","text":"The routing mechanism is based on Kemal which uses the radix tree implementation to identify the URL patterns. class DemoController < Grip :: Controllers :: Http def index ( context : Context ) : Context context . json ( nil ) end end class Application < Grip :: Application def routes # The routing occurs via the `get` macro which instantiates the controller class and assigns a route # to the routing mechanism. # # `GET /` -> CLIENT -> SERVER -> ROUTER -> ROUTE -> CONTROLLER -> index/1 # get \"/\" , DemoController , as : :index end end","title":"Intermediate routing"},{"location":"parameter_validation/","text":"Parameter validation is only supported for the JSON parameters. class DemoController < Grip :: Controllers :: Http def post ( context : Context ) : Context parameters = # A named tuple which has the types and variable names pre-defined. Parameters ( first_name : String , last_name : String , email : String , password : String ) # Load the information from a JSON parameter body. . form ( context . fetch_json_params ) # Validate the string containing only alpha characters, if the block returns false an error is raised. . valid? ( :first_name ) { | value | value . alpha? } . valid? ( :last_name ) { | value | value . alpha? } . valid? ( :email ) { | value | value . email? } . valid? ( :password ) { | value | value . alphanum? && value . size >= 8 } context . json ( parameters ) end end There are custom methods included from extension modules located in the extension folder of the Grip framework, which provide additional validation functionality to the native data structures.","title":"Parameter validation"},{"location":"pipe_basic/","text":"Basic authorization is based upon an Base64 encoded header present in the request. class Application def routes pipeline :auth , [ Pipes :: Basic . new ( \"username\" , \"password\" ) ] end end","title":"Basic authorization"},{"location":"pipe_client_ip/","text":"Client IP address is needed for tracking the requests, filtering blacklisted addresses and creating an authorization scheme for certain IP addresses. class DemoController < Grip :: Controllers :: Http def get ( context : Context ) : Context puts context . asssigns . client_ip context . json ( \"Hello, World!\" ) end end class Application < Grip :: Application def routes pipeline :api , [ Pipes :: ClientIp . new ] scope \"/\" do pipe_through :api get \"/\" , DemoController end end end","title":"Client IP"},{"location":"pipe_jwt/","text":"JWT authorization is based upon an Authorization header present in the request. class DemoController < Grip :: Controllers :: Http def get ( context : Context ) : Context context . json ( { \"decoded\" => context . assigns . jwt , } ) end end class Application < Grip :: Application def routes pipeline :api , [ Pipes :: Jwt . new ] scope \"/\" do pipe_through :api get \"/\" , DemoController end end end You can configure the JWT pipe by: Pipes :: Jwt . new ( secret_key : \"CoolSecret!@#$%^&*()_+\" , claims : { :aud => \"Authorization\" , :iss => \"MyCoolCompany LLC.\" , :sub => nil }, algorithm : JWT :: Algorithm :: HS256 ) You can use the encode and decode functions like this: # Keep in mind that you can still change the algorithm and secret_key by supplying the variables to the function. # # For example: # include Pipes::Twj # encode_and_sign( # data: { # \"id\" => 1 # }, # secret_key: \"MyCoolKey\", # algorithm: JWT::Algorithm::HS256 # ) # include Pipes :: Twj encode_and_sign ( data : { \"id\" => 1 } ) # Keep in mind that you can still change the algorithm and secret_key by supplying the variables to the function. # # For example: # include Pipes::Twj # decode_and_verify( # data: \"eyOinniewi==\", # claims: { # :aud => \"Nothing\", # :iss => \"NoOne\", # :sub => nil # }, # secret_key: \"MyCoolKey\", # algorithm: JWT::Algorithm::HS256 # ) # include Pipes :: Twj decode_and_verify ( data : \"eyOnwindOWNIRnoninWINR==\" # This is not valid JWT. )","title":"JWT authorization"},{"location":"pipe_middleware/","text":"Pipe middleware is the building block of the framework, some helpful pipes are included with the framework. Creating a custom pipe is as easy as creating an HTTP handler : class DemoPipe < Pipes :: Base def call ( context : HTTP :: Server :: Context ) : HTTP :: Server :: Context # Mutate the context and pass it on to the next handler. end end class DemoController < Grip :: Controllers :: Http def get ( context : Context ) : Context context . json ( \"Hello, World!\" ) end end class Application < Grip :: Application def routes # Creating a pipeline with a single pipe to be routed through. pipeline :web , [ DemoPipe . new ] pipeline :api , [ DemoPipe . new ] scope \"/\" do pipe_through :web get \"/\" , DemoController scope \"/users\" do # This will go through [:web, :api]. pipe_through :api get \"/\" , DemoController end end end end Advantage of the pipe over a raw middleware is that you can controll which routes go through the middleware and which don't.","title":"Pipe middleware"},{"location":"pipe_powered_by_header/","text":"Powered by header provides a pipe which allows you to respond with a header containing information about the server. class Application < Grip :: Application def routes pipeline :api , [ Pipes :: PoweredByHeader . new ] end end","title":"Powered by header"},{"location":"pipe_secure_headers/","text":"Secure headers are needed to avoid the problems which occur when the servers response can be bent to the clients will. class Application < Grip :: Application def routes pipeline :api , [ Pipes :: SecureHeaders . new ] end end","title":"Secure headers"},{"location":"raw_middleware/","text":"Important note: Using the raw middleware is not recommended since it is a global handler which most of the time is reserved for the core functionality. In Grip raw middlewares are mentioned as handlers, when creating a handler you include the HTTP::Handler module and define a call/1 function. class DemoHandler include HTTP :: Handler def call ( context : HTTP :: Server :: Context ) : HTTP :: Server :: Context # Mutate the context and pass it on to the next handler. end end class Application < Grip :: Application def router [ @log_handler , DemoHandler . new , # This is how you build a router stack and add a middleware to it, here are all the handlers available: https://github.com/grip-framework/grip/blob/master/src/grip/application.cr#L22 @http_handler ] of HTTP :: Handler end def routes # Add the middleware to the central stack. end end","title":"Raw middleware"},{"location":"runtime_flags/","text":"Logging and persistence flags \u00b6 1.Flag which outputs the events to a STDOUT as a text based log: # -D is used to define a compile time flag. crystal run ./src/application.cr -D verbose Configuration flags \u00b6 1.Flag which strips adds logging to the framework: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D logs 2.Flag which enables the Swagger UI support: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D swagger 3.Flag which enables the static file serving: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D serveStatic 4.Flag which enables the WebSocket support: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D websocket 5.Flag which disables the exception page: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D hideAllExceptions Environment flags \u00b6 1.Flag which switches the environment to testing: # -D is used to define a compile time flag. crystal run ./src/application.cr -D test","title":"Runtime flags"},{"location":"runtime_flags/#logging-and-persistence-flags","text":"1.Flag which outputs the events to a STDOUT as a text based log: # -D is used to define a compile time flag. crystal run ./src/application.cr -D verbose","title":"Logging and persistence flags"},{"location":"runtime_flags/#configuration-flags","text":"1.Flag which strips adds logging to the framework: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D logs 2.Flag which enables the Swagger UI support: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D swagger 3.Flag which enables the static file serving: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D serveStatic 4.Flag which enables the WebSocket support: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D websocket 5.Flag which disables the exception page: # -D is used to define a compile time flag. crystal run ./src/appliaction.cr -D hideAllExceptions","title":"Configuration flags"},{"location":"runtime_flags/#environment-flags","text":"1.Flag which switches the environment to testing: # -D is used to define a compile time flag. crystal run ./src/application.cr -D test","title":"Environment flags"},{"location":"scope/","text":"Scope defines a prefix for routes which will be nested in a block. class DemoController < Grip :: Controllers :: Http def get ( context : Context ) : Context context . json ( nil ) end end class Application < Grip :: Application def routes # The routing occurs via the `get` macro which instantiates the controller class and assigns a route # to the routing mechanism. # # `GET /api/v1/` -> CLIENT -> SERVER -> ROUTER -> ROUTE -> CONTROLLER -> get/1 # # `GET /api/v1/users/` -> CLIENT -> SERVER -> ROUTER -> ROUTE -> CONTROLLER -> get/1 # scope \"/api/v1\" do get \"/\" , DemoController scope \"/users\" do get \"/\" , DemoController end end end end","title":"Scope"},{"location":"ssl/","text":"Grip has built-in and easy to use SSL support, it can be configured easily and deployed instantly. To start your Grip application with SSL support, use: KEY = PATH_TO_THE_KEY CERTIFICATE = PATH_TO_THE_CERTIFICATE crystal run ./src/application.cr -Dwith_openssl","title":"SSL"},{"location":"static/","text":"Static file handler gives you an abilty to serve static files to clients. class Application < Grip :: Application def public_dir # The directory from which the files will be served \"./public\" end def fallthrough # This enables the fallthrough feature which moves the request on to the next handler if this the file is not found. false end def directory_listing # This enables directory listing for the static file handler true end end Make sure to compile using the runtime flag serveStatic : crystal run ./src/application.cr -DserveStatic","title":"Static resources"},{"location":"swagger/","text":"Swagger is in essence an Interface Description Language for describing RESTful APIs expressed using JSON. Swagger is used together with a set of open-source software tools to design, build, document, and use RESTful web services. The class with documentation: alias Document = Grip :: Annotations @ [ Document :: Controller ( description : \"An example HTTP controller\" ) ] class HttpController < Grip :: Controllers :: Http # See these documents for more information: # https://github.com/grip-framework/grip/blob/feature/swagger/src/grip/dsl/macros.cr#L38 # https://github.com/icyleaf/swagger/ @ [ Document :: Route ( method : \"GET\" , # You have to specify by hand. route : \"/api/v1/\" , # You have to specify by hand. description : \"This is a description.\" , summary : \"This route returns a response.\" , parameters : [] of Swagger :: Parameter , # https://github.com/icyleaf/swagger/blob/master/src/swagger/parameter.cr responses : [] of Swagger :: Response , # https://github.com/icyleaf/swagger/blob/master/src/swagger/response.cr request : nil , # https://github.com/icyleaf/swagger/blob/master/src/swagger/request.cr authorization : false , deprecated : false ) ] def get ( context : Context ) : Context context . halt end end The application which instructs the swagger macro to document the class: class Application < Grip :: Application def routes swagger [ HttpController ] scope \"/api/v1\" do get \"/\" , HttpController end end end Compile the program with a runtime flag -D swagger to gain the features.","title":"Swagger"},{"location":"testing/","text":"1.Add spec-grip to your shard.yml file as a dependencie. dependencies : grip : github : grip-framework/grip spec-grip : github : grip-framework/spec-grip 2.Then run shards to get the dependencies: $ shards install 3.Now you should require it before your files in your spec/spec_helper.cr require \"spec-grip\" require \"../src/your-grip-app\" For example, your Grip application: # src/your-grip-app.cr require \"grip\" class Index < Grip :: Controllers :: Http def get ( context : Context ) : Context context . text ( \"Hello, World!\" ) end end class Application < Grip :: Application def routes get \"/\" , Index end end app = Application . new app . run 4.Now you can easily test your Grip application in your specs. crystal spec -Dtest # spec/your-grip-app-spec.cr describe \"Your::Grip::App\" do # You can use get,post,put,patch,delete to call the corresponding route. it \"renders /\" do get \"/\" do | response | response . body . should eq \"Hello, World!\" end end end","title":"Testing"},{"location":"verbs/","text":"There are several HTTP verbs supported by the router: class Application < Grip :: Application def routes get \"/\" , DemoController # Routes all the `GET /` requests to DemoController.get/1 post \"/\" , DemoController # Routes all the `POST /` requests to DemoController.post/1 put \"/\" , DemoController # Routes all the `PUT /` requests to DemoController.put/1 delete \"/\" , DemoController # Routes all the `DELETE /` requests to DemoController.delete/1 patch \"/\" , DemoController # Routes all the `PATCH /` requests to DemoController.patch/1 head \"/\" , DemoController # Routes all the `HEAD /` requests to DemoController.head/1 options \"/\" , DemoController # Routes all the `OPTIONS /` requests to DemoController.options/1 end end","title":"Available verbs"},{"location":"web_socket_routing/","text":"WebSockets are easy to define and use thanks to the core team of the Crystal Programming Language. class DemoController < Grip :: Controllers :: WebSocket def on_open ( context : Context , socket : Socket ) : Void # Executed when a client opens a connection to the server. end def on_message ( context : Context , socket : Socket , message : String ) : Void # Executed when a client sends a message. end def on_ping ( context : Context , socket : Socket , message : String ) : Void # Executed when a client pings the server. end def on_pong ( context : Context , socket : Socket , message : String ) : Void # Executed when a server receives a pong. end def on_binary ( context : Context , socket : Socket , binary : Bytes ) : Void # Executed when a client sends a binary message. end def on_close ( context : Context , socket : Socket , error_code : HTTP :: WebSocket :: CloseCode | Int ?, message : String ) : Void # Executed when a client closes the connection to the server. end end class Application < Grip :: Application def routes pipeline :api , [ Pipes :: PoweredByHeader . new ] pipeline :web , [ Pipes :: SecureHeaders . new ] # WebSockets support the pipeline routing, keep in mind that # the `:id` URL here gives an option to fetch the `id` using the # `context : Context.fetch_path_params/0` function. scope \"/\" do pipe_through [ :web , :api ] ws \"/:id\" , DemoController end end end Make sure to compile the application with WebSocket support: crystal run ./src/appliaction.cr -D websocket","title":"WebSocket routing"}]}